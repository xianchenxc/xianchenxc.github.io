{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/ds&algorithms/greedy-algorithm/",
    "result": {"data":{"site":{"siteMetadata":{"title":"HelloCode"}},"markdownRemark":{"id":"50946b4d-4a09-51f7-a0ad-156d88310568","excerpt":"Introduction 贪心算法是在每一步选择中都选择当前状态下最好或最优的选择，从而希望导致结果时最好或最优的算法。 Props and Cons 优点：简单，易于实现，运行快 缺点：算法经常不能提供全局最优解。 When to Use…","html":"<h2>Introduction</h2>\n<p>贪心算法是在每一步选择中都选择<strong>当前状态</strong>下最好或最优的选择，从而希望导致结果时最好或最优的算法。</p>\n<h2>Props and Cons</h2>\n<ul>\n<li>优点：简单，易于实现，运行快</li>\n<li>缺点：算法经常不能提供全局最优解。</li>\n</ul>\n<h2>When to Use？</h2>\n<p>用贪心算法解决的问题需要满足两个特性：</p>\n<ol>\n<li>\n<p>贪心选择：问题的整体最优解可以通过一系列局部最优的选择来达到</p>\n</li>\n<li>\n<p>最优子结构：问题的最优解包含其子问题的最优解</p>\n</li>\n</ol>\n<h2>Applications</h2>\n<ol>\n<li><a href=\"https://www.youtube.com/watch?v=poWB2UCuozA\">Activity Selection Problem</a></li>\n<li>Huffman Coding</li>\n<li>Job Sequencing Problem</li>\n<li>Fractional Knapsack Problem</li>\n<li>Prim’s Minimum Spanning Tree</li>\n</ol>","frontmatter":{"title":"贪心算法","date":"January 06, 2024","description":null}},"previous":{"fields":{"slug":"/quickjs/leb128/"},"frontmatter":{"title":"LEB128 编码格式"}},"next":{"fields":{"slug":"/ds&algorithms/dynamic-programming/"},"frontmatter":{"title":"Dynamic Programming"}}},"pageContext":{"id":"50946b4d-4a09-51f7-a0ad-156d88310568","previousPostId":"6860959a-fa35-5e8d-8b47-53ec65e6b38c","nextPostId":"45f351a2-c6eb-50ba-b314-698fde757d95"}},
    "staticQueryHashes": ["2841359383","3257411868"]}