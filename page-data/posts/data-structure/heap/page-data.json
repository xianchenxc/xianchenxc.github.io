{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/data-structure/heap","result":{"data":{"markdownRemark":{"id":"3f76e5c2-e077-5cef-b981-6b3babccaa28","html":"<p>强调一下，本文所说的“堆”是指一种数据结构，和操作系统中常说的堆是不同的概念，🙅 不要混淆。</p>\n<h2 id=\"什么是堆\" style=\"position:relative;\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86\" aria-label=\"什么是堆 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什么是堆</h2>\n<p>维基百科给的定义：</p>\n<blockquote>\n<p>堆（Heap）是计算机科学中一种特别的<strong>完全二叉树</strong>。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的父节点，那么 P 的值会小于等于（或大于等于）C 的值”。若父节点的值恒小于等于子节点的值，此堆称为最小堆（min heap）；反之，若父节点的值恒大于等于子节点的值，此堆称为最大堆（max heap）。</p>\n</blockquote>\n<p>在堆排序中，我们通常使用的是最大堆。最小堆通常用于构造优先队列。</p>\n<h3 id=\"存储\" style=\"position:relative;\"><a href=\"#%E5%AD%98%E5%82%A8\" aria-label=\"存储 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>存储</h3>\n<p>二叉堆一般用<strong>数组</strong>来表示。表示堆的数组 A 包含两个属性：</p>\n<ul>\n<li>A.length(通常)给出数组元素的个数</li>\n<li>A.heap-size 表示有多少个堆元素存储在数组中</li>\n</ul>\n<h3 id=\"堆的性质\" style=\"position:relative;\"><a href=\"#%E5%A0%86%E7%9A%84%E6%80%A7%E8%B4%A8\" aria-label=\"堆的性质 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>堆的性质</h3>\n<p>1.最大堆</p>\n<p>最大堆性质是指除了根以外的所有节点 i 都要满足：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  A[PARENT(i)] ≥ A[i]</code></pre></div>\n<p>因此，堆的最大元素存放在根节点中，即 A[0] 为最大值。<em>注意，此时 A[A.heap-size -1] 不一定是最小值。</em></p>\n<p>2.最小堆</p>\n<p>最小堆则正好与之相反，最小堆的性质是指除了根以外的所有节点 i 都有：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  A[PARENT(i)] ≤ A[i]</code></pre></div>\n<p>最小堆的最小元素存放在根节点中。</p>\n<h2 id=\"基本操作\" style=\"position:relative;\"><a href=\"#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C\" aria-label=\"基本操作 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>基本操作</h2>\n<h3 id=\"维护堆的性质\" style=\"position:relative;\"><a href=\"#%E7%BB%B4%E6%8A%A4%E5%A0%86%E7%9A%84%E6%80%A7%E8%B4%A8\" aria-label=\"维护堆的性质 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>维护堆的性质</h3>\n<p>MAX-HEAPIFY 是用于维护最大堆性质的重要过程。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">它的输入为一个数组 A 和一个下标 i。在调用 MAX-HEAPIFY 的时候，我们假定左子树 LEFT 和右子树 RIGHT 都是最大堆，但此时 A[i] 有可能小于其孩子，这样就违背了最大堆的性质。</code></pre></div>\n<p>MAX-HEAPIFY 通过让 A[i] 的值在最大堆中“逐级下降”。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">MAX-HEAPIFY(A, i)\n  l = LEFT(i)\n  r = RIGHT(i)\n  largest = i\n  if l ≤ A.heap-size and A[l] &gt; A[largest]\n    largest = l\n  if r ≤ A.heap-size and A[r] &gt; A[largest]\n    largest = r\n  if largest ≠ i\n    exchange A[i] with A[largest]\n    MAX-HEAPIFY(A, largest)</code></pre></div>\n<p>时间复杂度为 O(logn)</p>\n<h3 id=\"建堆\" style=\"position:relative;\"><a href=\"#%E5%BB%BA%E5%A0%86\" aria-label=\"建堆 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>建堆</h3>\n<p>建堆有两个方法：</p>\n<ol>\n<li>从单节点的二叉堆开始，每次插入一个节点，其时间复杂度为 O(nlogn)；</li>\n<li>用自底而上的方法利用过程 MAX-HEAPIFY 把一个大小为 n = A.length 的数组 A[1…n] 转换为最大堆。时间复杂度为 O(n)。</li>\n</ol>\n<p>由此可见，第二种方法更优。子数组 A(⌊n/2⌋+1…n) 中的元素都是树的叶节点，叶节点可以看做是单节点的堆。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">BUILD-MAX-HEAP(A)\n  A.heap-size = A.length\n  for i = ⌊A.length/2⌋ downto 1\n    MAX-HEAPIFY(A, i)</code></pre></div>\n<h3 id=\"插入节点\" style=\"position:relative;\"><a href=\"#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9\" aria-label=\"插入节点 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>插入节点</h3>\n<p>在数组最末尾插入新节点，此时，新插入的元素可能会打破“堆性质”，就需要自下而上的调整子节点与父节点（称作上浮 up-heap）：比较当前节点与父节点，不满足“堆性质”则进行交换。时间复杂度为 O(logn).</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">UP-HEAP(A, i)\n  p = PARENT(i)\n  if p ≥ 0 and A[p] &lt; A[i]\n    exchange A[i] with A[p]\n    UP-HEAP(A, p)</code></pre></div>\n<h3 id=\"删除根节点\" style=\"position:relative;\"><a href=\"#%E5%88%A0%E9%99%A4%E6%A0%B9%E8%8A%82%E7%82%B9\" aria-label=\"删除根节点 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>删除根节点</h3>\n<p>删除根节点用于堆排序。</p>\n<p>对于最大堆，删除根节点就是删除最大值。然后，把堆存储的最后那个节点移到填在根节点处。再从上而下调整父节点与它的子节点，这一操作称为下沉（down-heap）.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">DOWN-HEAP(A, i)\n  MAX-HEAPIFY(A, i)</code></pre></div>\n<h3 id=\"合并两个二叉堆\" style=\"position:relative;\"><a href=\"#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E4%BA%8C%E5%8F%89%E5%A0%86\" aria-label=\"合并两个二叉堆 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>合并两个二叉堆</h3>\n<h2 id=\"使用场景\" style=\"position:relative;\"><a href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\" aria-label=\"使用场景 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>使用场景</h2>\n<h3 id=\"堆排序\" style=\"position:relative;\"><a href=\"#%E5%A0%86%E6%8E%92%E5%BA%8F\" aria-label=\"堆排序 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>堆排序</h3>\n<p>算法步骤：输入一个数组 A</p>\n<ol>\n<li>首先，建堆 BUILD-MAX-HEAP(A)</li>\n<li>依次将根节点和数组末尾元素进行交换，使得末尾元素最大，同时 A.heap-size 减一，再调整结构满足堆性质。</li>\n<li>反复执行步骤 2 直至 A.heap-size 为 0，此时数组 A 就是已经排好序的。</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">heapSort</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> heapSize <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">buildMaxHeap</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>heapSize <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> max <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> last <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>heapSize <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    arr<span class=\"token punctuation\">[</span>heapSize <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> max<span class=\"token punctuation\">;</span>\n    arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> last<span class=\"token punctuation\">;</span>\n    heapSize <span class=\"token operator\">-=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">downHeap</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> heapSize<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">buildMaxHeap</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> len <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> len <span class=\"token operator\">>>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">maxHeapify</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">maxHeapify</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arr<span class=\"token punctuation\">,</span> i</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> left <span class=\"token operator\">=</span> i <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"优先队列\" style=\"position:relative;\"><a href=\"#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97\" aria-label=\"优先队列 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>优先队列</h3>","fields":{"slug":"/posts/data-structure/heap","tagSlugs":null},"frontmatter":{"date":"2021-05-17T11:01:48.000Z","description":"对于数据结构-堆的学习和使用","tags":null,"title":"堆（Heap）","socialImage":{"publicURL":"/static/0249a8579cfb4088acaf23fcac068444/image-2.jpg"}}}},"pageContext":{"slug":"/posts/data-structure/heap"}},"staticQueryHashes":["251939775","401334301","825871152"]}