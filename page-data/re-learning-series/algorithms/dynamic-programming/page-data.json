{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/re-learning-series/algorithms/dynamic-programming/",
    "result": {"data":{"site":{"siteMetadata":{"title":"HelloCode"}},"markdownRemark":{"id":"aa6518d2-c1d4-53de-9c97-f29d6d912dcb","excerpt":"目标： 了解什么是动态规划 理清动态规划的核心原理 常用的动态规划的应用场景 What is Dynamic Programming? Dynamic Programming is a computer programming technique where an algorithm probleam is first…","html":"<p>目标：</p>\n<ol>\n<li>了解什么是动态规划</li>\n<li>理清动态规划的核心原理</li>\n<li>常用的动态规划的应用场景</li>\n</ol>\n<h2>What is Dynamic Programming?</h2>\n<blockquote>\n<p>Dynamic Programming is a computer programming technique where an algorithm probleam is first broken down into sub-problems, the results are saved, and then the sub-problems are optimized to find the overall solution - which usually has to do with finding the maximum and minimum range of the algorithmic query.</p>\n</blockquote>\n<p>动态规划，是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。</p>\n<h2>How does Dynamic Programming work?</h2>\n<p>Dynamic Programming works by break down complex problem into <strong>simpler subproblems</strong>. Then, finding optimal solutions to these subproblems. <strong>Memorization</strong> is a method that saves the outcomes of these processes so that the corresponding answers do not need to computed when thery are later needed.</p>\n<p>动态规划的核心思想是：</p>\n<ul>\n<li>拆分子问题：将复杂的问题拆成相对简单的子问题</li>\n<li>缓存：子问题会存在重叠部分，通过缓存，减少重复计算</li>\n</ul>\n<p>动态规划可以通过以下两种方式实现：</p>\n<h3>Top-down approach</h3>\n<p>在计算机科学中，我们通常使用递归算法来求解问题。如果子问题存在重叠，则可以通过缓存和记表的方式来减少重复计算。</p>\n<h3>Bottom-up approach</h3>\n<p>如果一个问题问题可以通过不断</p>\n<h2>Applications</h2>\n<h3>接雨水</h3>\n<p>问题链接：<a href=\"https://leetcode.cn/problems/trapping-rain-water/description/\">https://leetcode.cn/problems/trapping-rain-water/description/</a></p>\n<p>简单分析：假设第 i 根柱子能接 rain[i] 雨水，那么一共能接 rain[0] + rain[1] + … + rain[len - 1]，问题的关键在于如何计算第 i 根柱子能接多少雨水？第 i 根柱子能接多少雨水，取决于左/右侧最高的柱子高度的较小值 - 第 i 根柱子的高度，即:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">rain[i] = Math.min(maxLeft[i] - maxRight[i]) - height[i]</code></pre></div>\n<p>问题转变为：计算第 i 根柱子左右两边的最大高度，最简单的方法，遍历 [0, i) 和 (i, len)，时间复杂度为 O(n)，整体时间复杂度 O(n^2)</p>\n<p>我们注意到求 maxLeft[i] 和 maxLeft[i - 1]，其实重复遍历计算了 [0, i - 1]，这是没有必要的，当知道 maxLeft[i - 1] 时，只需要简单比较 maxLeft[i - 1] 和 height[i] 即可：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">maxLeft[i] = Math.max(maxLeft[i - 1], height[i - 1])</code></pre></div>\n<p>这样，计算 maxLeft[i] 的时间复杂度从 O(n) 变成 O(1)，整体复杂度变为 O(n)。</p>\n<h2>参考文档</h2>\n<p><a href=\"https://www.spiceworks.com/tech/devops/articles/what-is-dynamic-programming/\">What is Dynamic Programming?</a></p>","frontmatter":{"title":"Dynamic Programming","date":"January 06, 2024","description":null}},"previous":{"fields":{"slug":"/re-learning-series/algorithms/greedy-algorithm/"},"frontmatter":{"title":"贪心算法"}},"next":null},"pageContext":{"id":"aa6518d2-c1d4-53de-9c97-f29d6d912dcb","previousPostId":"1e88783b-3a54-5daa-a278-d82616ccaf67","nextPostId":null}},
    "staticQueryHashes": ["2841359383","3257411868"]}